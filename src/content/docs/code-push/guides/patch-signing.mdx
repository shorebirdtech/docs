---
title: Patch Signing
description: How to sign patches
sidebar:
  order: 19
---

{/* cspell:words outform pubout */}

In addition to our default security measures, Shorebird also provides optional
patch signing.

Patch signing allows developers to cryptographically sign patch updates with
their own keys. This ensures that no one (including Shorebird) can change the
content of your patches without your private cryptographic keys.

Signing works in two parts. First, `shorebird release` commands can take an
optional `--public-key-path` argument to embed a public key in your released
application. The Shorebird updater will enforce that only patches signed with a
corresponding private key will be allowed to load for applications that include
a public key.

Second, when you build your patch with `shorebird patch`, you can pass
`--private-key-path` to have Shorebird sign your patch with your private key.
This is required if you created your release with a public key included.

There are no required changes to your code and you can add or remove this
signing requirement at any time by simply making a new release of your
application.

## Adding patch signing to your application

To start, you will need an RSA key pair. Shorebird supports RSA keys in PEM
format (both PKCS#1 and PKCS#8).

By default, `shorebird` reads private and public keys from `.pem` files on disk.

### Cloud Signing & Key Management Services

Shorebird supports command-based signing for integration with cloud key
management services (AWS KMS, GCP Cloud KMS, Azure Key Vault, HashiCorp Vault),
hardware security modules (HSMs), and secrets managers (1Password, etc.).

Instead of storing keys on disk, you can use `--public-key-cmd` and `--sign-cmd`
to delegate key operations to external tools:

```sh
# Release with cloud-managed public key
shorebird release android \
  --public-key-cmd="your-command-that-outputs-pem-public-key"

# Patch with cloud-managed signing
shorebird patch android \
  --public-key-cmd="your-command-that-outputs-pem-public-key" \
  --sign-cmd="your-command-that-signs-stdin-and-outputs-base64"
```

**Contract:**
- `--public-key-cmd`: Command outputs a PEM-encoded public key to stdout
- `--sign-cmd`: Command reads data from stdin and outputs a base64 signature to stdout

See [Cloud KMS Examples](#cloud-kms-examples) below for integration examples
with popular services.

### Generate keys (file-based)

If you do not already have an RSA key pair you'd like to use, you can generate a
pair with `openssl`:

```sh
# Generate a key pair
openssl genrsa -out private.pem 2048

# Extract the public key
openssl rsa -in private.pem -outform PEM -pubout -out public.pem
```

:::note

On Windows, you can use the `openssl` that comes with your git installation at
`C:\Program Files\Git\usr\bin\openssl.exe`.

:::

The above operation will generate a public/private key pair in `private.pem` and
a public key in `public.pem`. The file containing the private key should be
stored securely and kept secret. While the private key is not itself sufficient
to make an update to your application (someone would also need access to your
Shorebird credentials), it should not be checked into public source control.

### Create a release containing the public key

To create a release that requires signed patches, run the following command:

```sh
shorebird release android --public-key-path /path/to/public.pem
```

This will include the public key in the release artifact produced by
`shorebird release` and cause the released app to require signed patches.

:::note

These examples use Android, but patch signing works on all platforms.

:::

### Create a signed patch

To create a signed patch, run the following command:

```sh
shorebird patch android --public-key-path /path/to/public.pem --private-key-path /path/to/private.pem
```

This tells shorebird to sign the patch with the key pair you provided.

:::tip[Enterprise Key Management]

For production environments, we recommend using `--public-key-cmd` and
`--sign-cmd` to integrate with your existing key management infrastructure
rather than storing keys on disk. See [Cloud KMS Examples](#cloud-kms-examples)
for integration patterns with AWS KMS, GCP Cloud KMS, HashiCorp Vault, and more.

:::

### Test it out

You can verify that the patch is properly signed using `shorebird preview`. On
the first launch, you should see something like the following in your app logs:

```
05-22 23:47:51.645  6963  6994 I flutter : updater::updater: Patch 1 successfully installed.
05-22 23:47:51.645  6963  6994 I flutter : updater::updater: Update thread finished with status: Update installed
```

If you close and relaunch your app, you should see this message telling you that
the patch's signature was verified:

```
05-23 11:32:33.944  7029  7029 I flutter : updater::cache::signing: Verifying patch signature...
05-23 11:32:33.944  7029  7029 I flutter : updater::cache::signing: Patch signature is valid
```

If the patch is missing a signature, or fails signature verification for any
reason, Shorebird will not load it, and will instead use any previously
installed and verifiable patch (if there is one) or the unpatched release
version of your app.

If you'd like to test the missing signature behavior, you can create a patch
without a private key and notice that `shorebird preview` rejects it. Similarly,
you can create a patch with a different private key to do the same.

## Fallback Behavior

Releases that contain a public key will reject all unsigned patches. If a patch
is missing a signature or its signature is invalid, Shorebird will reject this
patch at boot time. It will instead boot from the last known good patch (if
still on disk) or the release build of the app. This will not cause your app to
crash.

If for any reason you were to lose your private key, there is no way to create a
patch for an application containing the corresponding public key. Even Shorebird
is not able to create a patch for your application without your private key. In
such a case, you would need to make and distribute a new release of your
application to send patches to it.

## Trade Offs

Signature verification adds a small overhead at app launch (under 50ms in our
testing with a medium size app on a 5-year-old Android phone). This overhead
increases with application size. For very large apps, if this overhead shows up
on your benchmarks, you can set `patch_verification: install_only` in
`shorebird.yaml` to verify signatures only when patches are installed rather
than on every launch.

## Cloud KMS Examples

The following examples show how to integrate Shorebird patch signing with
popular key management services using `--public-key-cmd` and `--sign-cmd`.

### HashiCorp Vault

Vault's Transit secrets engine provides cryptographic operations without
exposing keys:

```sh
# Store your key in Vault Transit
vault write transit/keys/shorebird-signing type=rsa-2048

# Release
shorebird release android \
  --public-key-cmd="vault read -field=public_key transit/keys/shorebird-signing"

# Patch
shorebird patch android \
  --public-key-cmd="vault read -field=public_key transit/keys/shorebird-signing" \
  --sign-cmd="vault write -field=signature transit/sign/shorebird-signing \
    hash_algorithm=sha2-256 signature_algorithm=pkcs1v15 input=-"
```

### GCP Cloud KMS

GCP Cloud KMS outputs PEM format natively:

```sh
# Create a key ring and key
gcloud kms keyrings create shorebird --location=global
gcloud kms keys create signing-key --keyring=shorebird --location=global \
  --purpose=asymmetric-signing --default-algorithm=rsa-sign-pkcs1-2048-sha256

# Release
shorebird release android \
  --public-key-cmd="gcloud kms keys versions get-public-key 1 \
    --key=signing-key --keyring=shorebird --location=global"

# Patch (using a helper script for signing)
shorebird patch android \
  --public-key-cmd="gcloud kms keys versions get-public-key 1 \
    --key=signing-key --keyring=shorebird --location=global" \
  --sign-cmd="gcloud kms asymmetric-sign --version=1 \
    --key=signing-key --keyring=shorebird --location=global \
    --digest-algorithm=sha256 --input-file=- --signature-file=- | base64"
```

### AWS KMS

AWS KMS outputs DER format, which needs conversion to PEM:

```sh
# Create an RSA signing key
aws kms create-key --key-spec RSA_2048 --key-usage SIGN_VERIFY

# Create a helper script for public key (aws-kms-pubkey.sh)
#!/bin/bash
aws kms get-public-key --key-id alias/shorebird-signing --output text \
  --query PublicKey | base64 -d | openssl rsa -pubin -inform DER -outform PEM

# Create a helper script for signing (aws-kms-sign.sh)
#!/bin/bash
HASH=$(cat - | openssl dgst -sha256 -binary | base64)
aws kms sign --key-id alias/shorebird-signing \
  --signing-algorithm RSASSA_PKCS1_V1_5_SHA_256 \
  --message-type DIGEST --message "$HASH" \
  --output text --query Signature

# Release
shorebird release android --public-key-cmd="./aws-kms-pubkey.sh"

# Patch
shorebird patch android \
  --public-key-cmd="./aws-kms-pubkey.sh" \
  --sign-cmd="./aws-kms-sign.sh"
```

### Azure Key Vault

```sh
# Create a key in Azure Key Vault
az keyvault key create --vault-name myVault --name shorebird-signing \
  --kty RSA --size 2048

# Helper script for public key (azure-kv-pubkey.sh)
#!/bin/bash
az keyvault key download --vault-name myVault --name shorebird-signing \
  --encoding PEM --file /dev/stdout

# Helper script for signing (azure-kv-sign.sh)
#!/bin/bash
HASH=$(cat - | openssl dgst -sha256 -binary | base64 -w0)
az keyvault key sign --vault-name myVault --name shorebird-signing \
  --algorithm RS256 --digest "$HASH" --query value -o tsv

# Release
shorebird release android --public-key-cmd="./azure-kv-pubkey.sh"

# Patch
shorebird patch android \
  --public-key-cmd="./azure-kv-pubkey.sh" \
  --sign-cmd="./azure-kv-sign.sh"
```

### 1Password CLI

1Password can store and retrieve keys securely:

```sh
# Store your keys in 1Password
op item create --category="Secure Note" --title="Shorebird Signing" \
  "public_key[text]=$(cat public.pem)" \
  "private_key[text]=$(cat private.pem)"

# Helper script for signing (1password-sign.sh)
#!/bin/bash
PRIVATE_KEY=$(op item get "Shorebird Signing" --fields private_key)
cat - | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | base64

# Release
shorebird release android \
  --public-key-cmd="op item get 'Shorebird Signing' --fields public_key"

# Patch
shorebird patch android \
  --public-key-cmd="op item get 'Shorebird Signing' --fields public_key" \
  --sign-cmd="./1password-sign.sh"
```

### macOS Keychain (Local Development)

For local development on macOS, you can use the system keychain:

```sh
# Import your key into the keychain
security import private.pem -k ~/Library/Keychains/login.keychain-db

# Helper script for signing (keychain-sign.sh)
#!/bin/bash
# Note: This requires the key to be stored as an identity
security find-identity -v -p codesigning  # List available identities
cat - | openssl dgst -sha256 -sign <(security find-key -l "your-key-label" \
  -w ~/Library/Keychains/login.keychain-db) | base64

# For simpler setups, store the PEM in keychain as a generic password
security add-generic-password -a "shorebird" -s "signing-key" \
  -w "$(cat private.pem)"

# Helper script using generic password
#!/bin/bash
KEY=$(security find-generic-password -a "shorebird" -s "signing-key" -w)
cat - | openssl dgst -sha256 -sign <(echo "$KEY") | base64
```

### CI/CD Integration Tips

When using command-based signing in CI/CD pipelines:

1. **Use environment variables** for sensitive configuration (key IDs, vault
   addresses)
2. **Authenticate before running Shorebird** - ensure your cloud CLI is
   authenticated (e.g., `gcloud auth`, `aws configure`, `vault login`)
3. **Use service accounts** with minimal permissions for automated pipelines
4. **Consider wrapper scripts** that handle authentication and error handling
5. **Test commands independently** before integrating with Shorebird

Example GitHub Actions workflow:

```yaml
- name: Authenticate to GCP
  uses: google-github-actions/auth@v2
  with:
    credentials_json: ${{ secrets.GCP_SA_KEY }}

- name: Create signed patch
  run: |
    shorebird patch android \
      --public-key-cmd="gcloud kms keys versions get-public-key 1 \
        --key=signing-key --keyring=shorebird --location=global" \
      --sign-cmd="./scripts/gcp-sign.sh"
```
