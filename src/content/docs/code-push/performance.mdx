---
title: Patch Performance
description: Information on Patch Performance
sidebar:
  label: Patch
  order: 10
---

Shorebird uses its own fork of Flutter.

Our fork works exactly as Google's does, including passing all the same
functionality and performance tests.

Using Shorebird's fork will result in no change in your App relative to
Google's. If you believe there is an unintended change, please let us know and
we'd love to work with you to diagnose.

### Patching

Updating a Flutter app in production is unique to Shorebird's fork.

Updating a Flutter app with a "patch" will result in the app working exactly as
well as it does for a "release", just with new code.

However on iOS our patching mechanism is different from all of the other
platforms. This is due to restrictions from the Apple App Store.

The Apple App Store requires all updates to use an interpreter. An interpreter
is a software program that can run other programs (rather than running the
program directly on the hardware). Interpreters are slow, including ours.

To work around the performance limitations of an interpreter, Shorebird's
updating system is designed to avoid using the interpreter as much as possible.
When you make a "patch" with Shorebird, Shorebird examines the change and
attempts to set up the "patch" to only run the _new_ or _changed_ code within
the interpreter (slow), and thus leave all un-changed code running on the CPU
(fast).

### Why iOS patches are sometimes slow

Unfortunately, compilers, including Dart's, tend to make many non-local changes
to a program as a result of a local change.

This means that when you change one part of your program, sometimes as a result
Dart might change how it builds an entirely separate part of your program.

Imagine you have a part of your program:

before.dart

```
bool isEven<T extends int?>(T value) => value?.isEven ?? false;

void foo(int x) {
  print(isEven(x));
}
```

And you change it to add:

```
bool isEven<T extends int?>(T value) => value?.isEven ?? false;

void foo(int x) {
  print(isEven(x));
}

void bar(int? x) {
  print(isEven(x));
}
```

In that example, `isEven` and `foo` didn't change. So you would expect Shorebird
should be able to run both of those on the CPU (not have to use an interpreter).
However this is unfortunately not the case. In the "before" case, because isEven
was never called with nullable values Dart optimized away all of the null checks
in the compiled `isEven` code. (That's a good thing.) Unfortunately that means
that when the new code now used `isEven` in a nullable context the compiled
contents of "isEven" change, to include null checks. Since the contents of
isEven changed, Shorebird will conservatively assume that the behavior of all
callers of isEven might have changed as well and we will not use the CPU
versions of those either. Thus if your change (however small) might happen to
have caused the Dart compiler to reconsider optimizations for some other
critical section of code, tiny changes can sometimes cause large sections of
your application to "un-link" and run in the interpreter.

### Avoiding Performance Changes in iOS patches

Unfortunately there is currently no good way to predict if a patch will cause a
performance change to your application.

The good news is that this behavior is relatively rare. 9 out of 10 patches
exhibit no difference after patching and when performance impacting changes
occur, Shorebird's tooling and console will warn you. The bad news is that
predicting when a change will trigger the Dart compiler to cause non-local
changes to your program is very difficult.

When these non-local changes occur, the best thing to do is just try to make the
diff smaller and patch again. For many kinds of patches the performance
difference will be either not noticeable, or worth the trade-off as a stop-gap
between now and when a user can update from the stores.

We have several ideas and will continue to improve this behavior in the future.
